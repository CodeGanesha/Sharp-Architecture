//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local


namespace SharpArch.Specifications.NHibernate
{
    using System;

    using global::SharpArch.Domain;
    using global::SharpArch.Domain.PersistenceSupport;
    using global::SharpArch.Features.Specifications;
    using global::SharpArch.NHibernate;
    using global::SharpArch.NHibernate.NHibernateValidator;

    using Machine.Specifications;

    using global::SharpArch.Testing.NUnit.NHibernate;

    public class has_unique_domain_signature_specs
    {
        public abstract class specification_for_has_unique_domain_signature_validator
        {
            protected static IEntityDuplicateChecker entityDuplicateChecker;

            Establish context = () =>
            {
                entityDuplicateChecker = new EntityDuplicateChecker();
                entityDuplicateChecker.AddToServiceLocator();
            };

            Cleanup after = ServiceLocatorHelper.Reset;
        }

        [Subject(typeof(HasUniqueDomainSignatureAttribute))]
        public class when_validating_an_entity_and_a_duplicate_exists : specification_for_has_unique_domain_signature_validator
        {
            static Contractor duplicateContractor;
            static bool result;

            Establish context = () =>
            {
                var contractor = new Contractor() { Name = "codai" };
                NHibernateSession.Current.Save(contractor);
                RepositoryTestsHelper.FlushSessionAndEvict(contractor);
                duplicateContractor = new Contractor() { Name = "codai" };
            };

            Because of = () =>
            {
                result = duplicateContractor.IsValid();
            };

            It should_say_the_entity_is_invalid = () => result.ShouldBeFalse();
        }

        [Subject(typeof(HasUniqueDomainSignatureWithGuidIdAttribute))]
        public class when_validating_an_entity_with_a_guid_id_and_a_duplicate_exists : specification_for_has_unique_domain_signature_validator
        {
            static ObjectWithGuidId duplicateObjectWithGuidId;
            static bool result;

            Establish context = () =>
            {
                var objectWithGuidId = new ObjectWithGuidId { Name = "codai" };
                NHibernateSession.Current.Save(objectWithGuidId);
                RepositoryTestsHelper.FlushSessionAndEvict(objectWithGuidId);
                duplicateObjectWithGuidId = new ObjectWithGuidId { Name = "codai" };
            };

            Because of = () => result = duplicateObjectWithGuidId.IsValid();

            It should_say_the_entity_is_invalid = () => result.ShouldBeFalse();
        }

        [Subject(typeof(HasUniqueDomainSignatureWithStringIdAttribute))]
        public class when_validating_an_entity_with_a_string_id_and_a_duplicate_exists : specification_for_has_unique_domain_signature_validator
        {
            static User duplicateUser;
            static bool result;

            Establish context = () =>
            {
                var user = new User("user1", "123-12-1234");
                NHibernateSession.Current.Save(user);
                RepositoryTestsHelper.FlushSessionAndEvict(user);
                duplicateUser = new User("user2", "123-12-1234");
            };

            Because of = () => result = duplicateUser.IsValid();

            It should_say_the_entity_is_invalid = () => result.ShouldBeFalse();
        }

        [Subject(typeof(HasUniqueDomainSignatureAttribute))]
        public class when_validating_an_entity_and_the_entity_is_unique : specification_for_has_unique_domain_signature_validator
        {
            static Contractor contractor;
            static bool result;

            Establish context = () =>
            {
                contractor = new Contractor { Name = "the name" };
            };

            Because of = () => result = contractor.IsValid();

            It should_say_the_entity_is_valid = () => result.ShouldBeTrue();
        }

        [Subject(typeof(HasUniqueDomainSignatureAttribute))]
        public class when_validating_an_entity_with_the_wrong_validator_type : specification_for_has_unique_domain_signature_validator
        {
            static ObjectWithStringIdAndValidatorForIntId entity;
            static Exception result;

            Establish context = () =>
            {
                Check.UseAssertions = false;
                entity = new ObjectWithStringIdAndValidatorForIntId { Name = "whatever" };
            };

            Because of = () => result = Catch.Exception(() => entity.IsValid());

            It should_throw_a_precondition_exception = () => result.ShouldBeOfType(typeof(PreconditionException));
        }
    }
}